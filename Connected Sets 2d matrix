using System;

class Program
{
    static void Main()
    {
        int t = int.Parse(Console.ReadLine());
        while (t--> 0)
        {
            int n = int.Parse(Console.ReadLine()), cc = 0;
            int[,] matrix = new int[n, n];
            for (int i = 0; i < n; i++)
            {
                var row = Console.ReadLine().Split();
                for (int j = 0; j < n; j++) matrix[i, j] = int.Parse(row[j]);
            }
            void DFS(int x, int y)
            {
                if (x < 0 || y < 0 || x >= n || y >= n || matrix[x, y] == 0) return;
                matrix[x, y] = 0;
                foreach (var (dx, dy) in new[] { (-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1) })
                    DFS(x + dx, y + dy);
            }
            for (int i = 0; i < n; i++)
                for (int j = 0; j < n; j++)
                    if (matrix[i, j] == 1) { DFS(i, j); cc++; }
            Console.WriteLine(cc);
        }
    }
}



/*
Depth First Search (DFS): The DFS function explores the matrix recursively in all 8 directions for each cell with a value of 1, marking visited cells as 0.
O(T × N²): For each test case (T), the matrix traversal requires N × N checks. The DFS visits each cell once. ---> Time Complexity


Space Complexity:
- O(N²): Space is required to store the matrix.
- O(N) (Call Stack): In the worst case, recursion depth is proportional to the matrix size (for a single connected component).







*/
